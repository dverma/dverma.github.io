---
layout: post
title:  "The Big O"
date:   2017-02-13
excerpt: "The Big O - What, Why & When?"
tag:
- Big O
- algorithms
image: 'assets/blog_images/bigO.png'
comments: true
---

## Motivation for this post
It's been a while since I brushed up my knowledge of the basic algorithms and raw implementations of various data structures and as a software engineer that's *bad*, like *real real bad*.
In the corporate world making enterprise level software built upon frameworks that do most of the heavy lifting when it comes to the efficiency, we tend to ignore the basics. Well, its time I touch up on those again, so here goes.
A little humor before we start though, like seriously, what would life be like if it was all business.
![Who better than Randall Munroe](http://imgs.xkcd.com/comics/1337_part_2.png)


# The Big O - What, Why & When?

## What is The Big O?

#### *According to Wikipedia:*

> Big O notation is a mathematical notation that describes the limiting behavior of a function when the argument tends towards a particular value or infinity.
>
> Big O notation characterizes functions according to their growth rates: different functions with the same growth rate may be represented using the same O notation.
>
> The letter O is used because the growth rate of a function is also referred to as order of the function. A description of a function in terms of big O notation usually only provides an upper bound on the growth rate of the function. Associated with big O notation are several related notations, using the symbols \(o, Ω, ω and  Θ \), to describe other kinds of bounds on asymptotic growth rates.

The Big O is the order of a function/algorithm \\(O(n)\\) where n is the size of input to the function/algorithm.

Big O notation is used in Computer Science to describe the performance or complexity of an algorithm; specifically the worst-case scenario(upper bound on the growth rate of the function), and can be used to describe the execution time required or the space used (e.g. in memory or on disk) by an algorithm.

Let's see some common order of functions and a few examples:

### Constant - \\(O(1)\\)

{% highlight java %}
//Swap ith and jth element in an array
void swap(int[] arr, int i, int j)
{
  int temp = arr[i];
  arr[i] = arr[j];
  arr[j] = temp;
}
{% endhighlight %}

### Logarithmic - \\(O({log_2} n)\\) 

{% highlight java %}

{% endhighlight %}

### Linear - \\(O(n)\\)

{% highlight java %}

{% endhighlight %}

### QuasiLinear - \\(O(n log^{k} n)\\) \\(for some constant\\) \\(k>=1\\)

{% highlight java %}

{% endhighlight %}

### Polynomial - \\(O(n^{k})\\) \\(for some constant\\) \\(k>1\\)

{% highlight java %}

{% endhighlight %}

### Exponential - \\(O(2^{n^{k}})\\) \\(for some constant\\) \\(k\\)

{% highlight java %}

{% endhighlight %}



## Why is it important?


## When is it important?
>  When is it not?
